pipeline {
    agent any
    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: 'Branch to build from')
        string(name: 'REPO_URL', defaultValue: 'https://github.com/dkojo/new-microservices-ecs.git', description: 'Repository URL to build from')
        string(name: 'TASK_DEF_JSON', defaultValue: 'continuous-integration-continuous-deployment/task-def.json', description: 'Path to the task definition JSON file')
        string(name: 'CREATE_SERVICE_FILE', defaultValue: 'continuous-integration-continuous-deployment/create-ecs-service.json', description: 'Path to the create service JSON file')
        string(name: 'UPDATE_SERVICE_FILE', defaultValue: 'continuous-integration-continuous-deployment/update-ecs-service.json', description: 'Path to the update service JSON file')
        string(name: 'SERVICE_NAME', defaultValue: 'itgenius-microservice-ecs-app-dev-service', description: 'ECS Service Name')
        string(name: 'ECS_CLUSTER_NAME', defaultValue: 'itgenius-microservice-ecs-app-dev-cluster', description: 'ECS Cluster Name')
        string(name: 'ECR_REPO_NAME', defaultValue: 'itgenius-microservice-ecs-app-dev-repo', description: 'ECR Repository Name')
        string(name: 'AWS_ACCOUNT_ID', defaultValue: '870342665742', description: 'The AWS Account ID where the ECR repository and Cluster is located')
        string(name: 'REGION', defaultValue: 'us-east-1', description: 'AWS Region where the ECR repository and Cluster is located')
        string(name: 'IMAGE_NAME', defaultValue: 'itgenius-microservice-ecs-app-dev', description: 'Name of the Docker image to be built')
        string(name: 'SONARQUBE_SERVER_NAME', defaultValue: 'sonarqube_server', description: 'Name for your SonarQube server')
    }

    environment {
        BRANCH = "${params.BRANCH}"
        REPO_URL = "${params.REPO_URL}"
        VERSION = "V00${env.BUILD_ID}"
        TASK_DEF_JSON = "${params.TASK_DEF_JSON}"
        CREATE_SERVICE_FILE = "${params.CREATE_SERVICE_FILE}"
        UPDATE_SERVICE_FILE = "${params.UPDATE_SERVICE_FILE}"
        SERVICE_NAME = "${params.SERVICE_NAME}"
        ECS_CLUSTER_NAME = "${params.ECS_CLUSTER_NAME}"
        AWS_ACCOUNT_ID = "${params.AWS_ACCOUNT_ID}"
        REGION = "${params.REGION}"
        IMAGE_NAME = "${params.IMAGE_NAME}"
        SONARQUBE_SERVER_NAME = "${params.SONARQUBE_SERVER_NAME}"
    }

    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Clone GitHub Repo') {
            steps {
                git branch: "${BRANCH}", credentialsId: 'github_creds', url: "${REPO_URL}"
            }
        }

        stage('Application Build') {
            steps {
                sh 'chmod +x ./mvnw'
                sh './mvnw clean install'
            }
        }

        stage('Application Test') {
            steps {
                sh 'chmod +x ./mvnw'
                sh './mvnw test'
            }
        }

        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv("${SONARQUBE_SERVER_NAME}") {
                        sh './mvnw sonar:sonar'
                    }
                }
            }
        }

        stage('Building Docker Image') {
            steps {
                sh "docker build -t ${IMAGE_NAME} ."
            }
        }

        stage('Docker Image Vulnerability Scan') {
            steps {
                script {
                    echo "Running Trivy vulnerability scan on local image: ${IMAGE_NAME}"

                    sh """
                        export TMPDIR=/var/tmp/trivy
                        export TRIVY_CACHE_DIR=/var/tmp/trivy-cache
                        trivy image --no-progress --exit-code 0 ${IMAGE_NAME}
                    """
                }
            }
        }

        stage('Push To Elastic Container Registry') {
            steps {
                script {
                        sh """
                            aws ecr get-login-password --region ${REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com
                            docker tag ${IMAGE_NAME} ${AWS_ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO_NAME}:${VERSION}
                            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO_NAME}:${VERSION}
                        """
                    
                }
            }
        }

        stage('Update Task Definition') {
            steps {
                script {
                        def image = "${AWS_ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO_NAME}:${VERSION}"
                        def taskDefJson = readFile(file: TASK_DEF_JSON)
                        taskDefJson = taskDefJson.replaceAll(/"image": "${AWS_ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com\/${ECR_REPO_NAME}:[^"]+"/, "\"image\": \"${image}\"")
                        writeFile(file: TASK_DEF_JSON, text: taskDefJson)
                }
            }
        }

        stage('Register Task Definition') {
            steps {
                script {
                        def taskDefArn = sh(script: """
                            aws ecs register-task-definition --cli-input-json file://${TASK_DEF_JSON} --query 'taskDefinition.taskDefinitionArn' --region ${REGION} --output text
                        """, returnStdout: true).trim()

                        echo "Task Definition ARN: ${taskDefArn}"

                        def createServiceJson = readFile(file: CREATE_SERVICE_FILE)
                        createServiceJson = createServiceJson.replaceAll(/"taskDefinition": "arn:aws:ecs:[^"]+"/, "\"taskDefinition\": \"${taskDefArn}\"")
                        writeFile(file: CREATE_SERVICE_FILE, text: createServiceJson)

                        def updateServiceJson = readFile(file: UPDATE_SERVICE_FILE)
                        updateServiceJson = updateServiceJson.replaceAll(/"taskDefinition": "arn:aws:ecs:[^"]+"/, "\"taskDefinition\": \"${taskDefArn}\"")
                        writeFile(file: UPDATE_SERVICE_FILE, text: updateServiceJson)
                }
            }
        }

        stage('Stop all running tasks') {
            steps {
                script {
                        def serviceExists = sh(script: """
                            aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --region ${REGION} --output text
                        """, returnStdout: true).trim()

                        if (serviceExists) {
                            sh """
                                tasks=\$(aws ecs list-tasks --cluster ${ECS_CLUSTER_NAME} --service-name ${SERVICE_NAME} --region ${REGION} --desired-status RUNNING --query taskArns --output text)
                                for task in \$tasks; do
                                    aws ecs stop-task --cluster ${ECS_CLUSTER_NAME} --region ${REGION} --task \$task
                                done
                            """
                        } else {
                            echo "Service ${SERVICE_NAME} does not exist. Skipping stop tasks step."
                    }
                }
            }
        }

        stage('Wait for Tasks to Stop') {
            steps {
                script {
                        def serviceExists = sh(script: """
                            aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --region ${REGION} --output text
                        """, returnStdout: true).trim()

                        if (serviceExists) {
                            timeout(time: 5, unit: 'MINUTES') {
                                waitUntil {
                                    def tasks = sh(script: """
                                        aws ecs list-tasks --cluster ${ECS_CLUSTER_NAME} --service-name ${SERVICE_NAME} --desired-status RUNNING --query taskArns --region ${REGION} --output text
                                    """, returnStdout: true).trim()

                                    return tasks == null || tasks.isEmpty()
                                }
                            }
                        } else {
                            echo "Service ${SERVICE_NAME} does not exist. Skipping wait for tasks to stop step."
                        }
                }
            }
        }

        stage('Check and Update ECS Service') {
            steps {
                script {
                        def clientToken = UUID.randomUUID().toString()
                        sh """
                            SERVICE_EXISTS=\$(aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --region ${REGION} --output text)

                            if [ -z "\$SERVICE_EXISTS" ]; then
                              echo "Service ${SERVICE_NAME} does not exist. Creating service..."
                              aws ecs create-service --cli-input-json file://${CREATE_SERVICE_FILE} --client-token ${clientToken} --region ${REGION}
                            else
                              echo "Service ${SERVICE_NAME} exists. Updating service..."
                              aws ecs update-service --cli-input-json file://${UPDATE_SERVICE_FILE} --region ${REGION}
                            fi
                        """
                }
            }
        }
        stage('Wait for ECS Service Stabilization') {
            steps {
                script {
                sh """
                    aws ecs wait services-stable \
                    --cluster ${ECS_CLUSTER_NAME} \
                    --services ${SERVICE_NAME} \
                    --region ${REGION}
                """
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    def serviceExists = sh(script: """
                        aws ecs describe-services --cluster ${ECS_CLUSTER_NAME} --services ${SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --region ${REGION} --output text
                    """, returnStdout: true).trim()

                    if (serviceExists) {
                        echo "Deployment successful. Service ${SERVICE_NAME} is running."
                    } else {
                        error "Deployment failed. Service ${SERVICE_NAME} does not exist."
                    }
                }
            }
        }
    }
}
        
